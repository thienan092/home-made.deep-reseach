<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thought-Spinning Bot</title>

    <!-- ICON LUCIDE BOT CHO FAVICON -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg%20width='64'%20height='64'%20viewBox='0%200%2024%2024'%20xmlns='http://www.w3.org/2000/svg'%20fill='%23374151'%20stroke='none'%3E%3Cpath%20d='M12%208V4H8'/%3E%3Crect%20width='16'%20height='12'%20x='4'%20y='8'%20rx='2'/%3E%3Cpath%20d='M2%2014h2'/%3E%3Cpath%20d='M20%2014h2'/%3E%3Cpath%20d='M15%2013v2'/%3E%3Cpath%20d='M9%2013v2'/%3E%3C/svg%3E">

    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js for rendering Markdown from Gemini -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Lucide Icons for UI elements -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for a cleaner interface */
        #chat-container::-webkit-scrollbar {
            width: 6px;
        }
        #chat-container::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        #chat-container::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 3px;
        }
        #chat-container::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }
        .api-key-input {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid #cbd5e1;
            background-color: #f8fafc;
        }
        .api-key-input:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 2px #c7d2fe;
        }
        /* Styles for Markdown content */
        .prose p { margin-bottom: 1rem; }
        .prose ul { list-style-position: inside; }
        .prose li { margin-bottom: 0.5rem; }
        .prose h1, .prose h2, .prose h3, .prose h4, .prose h5, .prose h6 { margin-top: 1.5rem; margin-bottom: 1rem; font-weight: 600; }
        .prose h1 { font-size: 1.875rem; }
        .prose h2 { font-size: 1.5rem; }
        .prose h3 { font-size: 1.25rem; }
        .prose code { background-color: #e2e8f0; padding: 0.2em 0.4em; border-radius: 0.25rem; font-size: 0.875em; }
        .prose pre { background-color: #1e293b; color: #f8fafc; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; }
        .prose a { color: #4f46e5; text-decoration: underline; }


        /* CSS for loading icon */
        
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @keyframes dot-blink { /* Renamed for clarity */
            0% { content: ''; }
            25% { content: '.'; }
            50% { content: '..'; }
            75% { content: '...'; }
            100% { content: ''; }
        }

        .dot-effect::after { /* Renamed for clarity */
            content: '';
            animation: dot-blink 1.5s infinite steps(1); /* Using new animation */
            display: inline-block;
            width: 1.5em;
            text-align: left;
        }

        /* Styles for receiver iframe container */
        #receiver-container { /* Renamed */
            position: fixed; /* Always fixed for these states */
            right: 0;
            top: 0;
            height: 100vh;
            background-color: #f0f2f5;
            box-shadow: -5px 0 15px rgba(0,0,0,0.2);
            transition: width 0.3s ease-in-out, padding 0.3s ease-in-out, left 0.3s ease-in-out, right 0.3s ease-in-out; /* Transition all relevant properties */
            display: flex;
            flex-direction: column;
            z-index: 9999; /* On top of bookmark tab */
            padding: 1rem; /* Default padding for partial/fullscreen mode */
            border-radius: 0; /* No border radius for main container */
            overflow: hidden; /* Prevent content overflow during transition */
        }

        /* Specific width by state */
        #receiver-container.state-bookmark { /* Renamed */
            width: 0; /* Hidden, only bookmark tab visible */
            padding: 0; /* No padding when hidden */
            left: auto; /* Ensure it's on the right */
            right: 0;
        }

        #receiver-container.state-partial { /* Renamed */
            width: 20vw; /* 1/5 viewport width */
            left: auto; /* Ensure it's on the right */
            right: 0;
        }

        #receiver-container.state-fullscreen { /* Renamed */
            width: 100vw;
            left: 0; /* Ensure it takes full width from left */
            right: 0; /* Ensure it takes full width to right */
            padding: 0; /* Remove padding in fullscreen mode to avoid cutting header */
        }

        /* Iframe visibility */
        #receiver-iframe { /* Renamed */
            width: 100%;
            flex-grow: 1; /* Make it fill remaining height */
            border: none;
            background-color: white; /* Ensure iframe background is white */
            transition: opacity 0.3s ease-in-out; /* Add opacity transition */
        }

        /* Header */
        #receiver-container .receiver-header { /* Renamed */
            display: none; /* Hidden by default */
            justify-content: space-between;
            align-items: center;
            /* Remove negative margins that caused overflow */
            padding: 1rem; /* Consistent padding for header */
            background-color: #1e293b; /* Dark header for fullscreen */
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            /* Adjust border-radius for the header itself */
            border-top-right-radius: 0; /* No rounded corners for header in fullscreen */
            border-top-left-radius: 0; /* No rounded corners for header in fullscreen */
        }

        #receiver-container.state-fullscreen .receiver-header { /* Renamed */
            display: flex; /* Show in fullscreen mode */
        }

        /* Styles for bookmark tab */
        #iframe-bookmark-tab { /* Renamed */
            position: fixed;
            right: 0; /* Initial position */
            top: 50%;
            transform: translateY(-50%);
            width: 48px; /* Small width for tab */
            height: 100px; /* Height of tab */
            background-color: rgba(66, 153, 225, 0.7); /* Blue, slightly transparent */
            border-top-left-radius: 10px;
            border-bottom-left-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 9998; /* Below fullscreen, above chat */
            transition: right 0.3s ease-in-out, background-color 0.3s ease-in-out, opacity 0.3s ease-in-out; /* Add "right" to transition */
            box-shadow: -2px 0 5px rgba(0,0,0,0.2);
        }

        #iframe-bookmark-tab:hover { /* Renamed */
            background-color: rgba(66, 153, 225, 0.9); /* Slightly less transparent on hover */
        }

        /* Custom animation for bar chart icon (kept from original index.html) */
        @keyframes bar-animation {
            0%, 100% { transform: translateY(0); opacity: 1; }
            50% { transform: translateY(-4px); opacity: 0.8; }
        }

        .send-receiver-size-btn:hover .bar-1,
        .send-receiver-size-btn:hover .bar-2,
        .send-receiver-size-btn:hover .bar-3 {
            animation: bar-animation 1s ease-in-out infinite;
        }

        .send-receiver-size-btn:hover .bar-1 {
            animation-delay: 0s;
        }
        .send-receiver-size-btn:hover .bar-2 {
            animation-delay: 0.2s;
        }
        .send-receiver-size-btn:hover .bar-3 {
            animation-delay: 0.4s;
        }

        /* Styles for suggestions */
        .suggestion-btn {
            @apply bg-gray-200 hover:bg-gray-300 text-gray-800 text-sm font-medium py-1 px-3 rounded-full transition-colors duration-200;
        }

        /* Styles for textarea */
        #chat-input {
            resize: vertical; /* Allow vertical resizing */
            min-height: 48px; /* Minimum height equal to send button */
            max-height: 150px; /* Maximum height to not take too much space */
            overflow-y: auto; /* Add scrollbar when content overflows */
        }

        /* Hide send receiver size button by default */
        .send-receiver-size-btn {
            display: none;
        }

        /* --- CSS MỚI CHO ICON CÀ PHÊ --- */
        @keyframes steam-rise {
            0% { transform: translateY(0); opacity: 0; }
            40% { opacity: 0.9; }
            80% { transform: translateY(-12px); opacity: 0; }
            100% { transform: translateY(-12px); opacity: 0; }
        }
        .coffee-steam {
            stroke: currentColor;
            stroke-width: 2.5;
            stroke-linecap: round;
            animation: steam-rise 3s infinite ease-in-out;
            opacity: 0;
        }
        .coffee-steam.steam-1 { animation-delay: 0s; }
        .coffee-steam.steam-2 { animation-delay: 1s; }
        .coffee-steam.steam-3 { animation-delay: 1.8s; }
        /* --- KẾT THÚC CSS MỚI --- */
    </style>
</head>
<body>

    <div class="max-w-4xl w-full mx-auto p-4 flex-grow flex flex-col">
        <!-- Header and API Key Section -->
        <div class="bg-white p-4 rounded-xl shadow-md mb-4 border border-slate-200">
            <div class="flex items-center justify-between mb-4">
                <h1 class="text-2xl font-bold text-slate-800">Thought-Spinning Bot</h1>
                <div class="flex items-center gap-3">
                    <!-- Search Mode Selector -->
                    <div class="relative">
                        <select id="search-mode-selector" class="block appearance-none w-full bg-white border border-slate-300 text-slate-700 py-2 px-3 pr-8 rounded-lg leading-tight focus:outline-none focus:bg-white focus:border-indigo-500">
                            <option value="limited">Limited (Restricted Search)</option>
                            <option value="unlimited">Unlimited (Extended Search)</option>
                            <option value="backend">Back-end (Deep Dive)</option>
                            <option value="quota">Quota (Gemini Data)</option>
                            <option value="quota-backend">Quota (Simulated Back-end)</option>
                        </select>
                        <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-slate-700">
                            <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 6.757 7.586 5.343 9z"/></svg>
                        </div>
                    </div>
                    <button id="show-key-button" class="text-slate-500 hover:text-slate-800">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-key-round"><path d="M2 18v3c0 .6.4 1 1 1h4v-3h3v-3h2l1.4-1.4a6.5 6.5 0 1 0-4-4Z"/><circle cx="16.5" cy="7.5" r=".5"/></svg>
                    </button>
                </div>
            </div>
            <div id="api-key-section" class="mt-4 space-y-3 hidden">
                <div>
                    <label for="gemini-api-key" class="text-sm font-medium text-slate-600">Gemini Flash API Key</label>
                    <input type="password" id="gemini-api-key" class="api-key-input" placeholder="Please enter your Gemini API key (optional)">
                    <p class="text-xs text-slate-500 mt-1">Get your Gemini API key here: <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-indigo-600 hover:underline">Google AI Studio</a> (If left blank, Canvas will automatically provide it)</p>
                </div>
                <div>
                    <label for="google-api-key" class="text-sm font-medium text-slate-600">Google Search API Key</label>
                    <input type="password" id="google-api-key" class="api-key-input" placeholder="Enter your Google Search API key">
                    <p class="text-xs text-slate-500 mt-1">Get your Google Search API key (and enable Custom Search API) here: <a href="https://console.developers.google.com/apis/credentials" target="_blank" class="text-indigo-600 hover:underline">Google Cloud Console</a></p>
                </div>
                <div>
                    <label for="google-cx" class="text-sm font-medium text-slate-600">Google Search Engine ID (CX)</label>
                    <input type="text" id="google-cx" class="api-key-input" placeholder="Enter your Search Engine ID (CX)">
                    <p class="text-xs text-slate-500 mt-1">Create your Search Engine ID (CX) here: <a href="https://programmablesearchengine.google.com/controlpanel/all" target="_blank" class="text-indigo-600 hover:underline">Google Programmable Search Engine</a> (Select "Entire web" search)</p>
                </div>
                <p class="text-xs text-slate-500">API keys are stored in the browser and are not sent anywhere other than Google's APIs.</p>
            </div>
        </div>

        <!-- Chat Container -->
        <div id="chat-container" class="flex-grow bg-white rounded-xl shadow-md p-6 overflow-y-auto border border-slate-200">
            <!-- Messages will be appended here -->
            <div class="flex items-start gap-3">
                <div class="bg-indigo-600 p-2 rounded-full flex-shrink-0">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucude-bot"><path d="M12 8V4H8"/><rect width="16" height="12" x="4" y="8" rx="2"/><path d="M2 14h2"/><path d="M20 14h2"/><path d="M15 13v2"/><path d="M9 13v2"/></svg>
                </div>
                <div class="bg-slate-100 text-slate-800 rounded-lg p-3 max-w-full">
                    <p class="font-semibold mb-2">Hello! How can I help you?</p>
                    <p class="text-sm">Please enter your <span class="font-bold">Gemini Flash API key</span> to use the bot. This key is required for all search modes, including "Quota" modes.</p>
                    <p class="text-sm mt-2">If you want to use "Limited", "Unlimited" or "Back-end" search modes, you also need to provide your <span class="font-bold">Google Search API key</span> and <span class="font-bold">Search Engine ID (CX)</span> by clicking the key icon above.</p>
                    <p class="text-sm mt-3">Select your desired search mode (default is "Limited").</p>
                </div>
            </div>
        </div>

        <!-- Input Form -->
        <div class="mt-4">
            <div id="suggestions-container" class="flex flex-wrap gap-2 mb-3">
                <!-- Suggest Information Extraction button -->
                <button id="suggest-extraction-button" class="bg-gray-300 hover:bg-gray-400 text-gray-800 text-sm font-medium py-1 px-3 rounded-full transition-colors duration-200">
                    Suggest Information Extraction
                </button>
                <!-- Other suggestions will be dynamically added here -->
            </div>
            <form id="chat-form" class="flex items-center gap-3">
                <textarea id="chat-input" class="flex-grow p-3 rounded-lg border border-slate-300 focus:ring-2 focus:ring-indigo-500 focus:outline-none transition" placeholder="Ask a complex question..." autocomplete="off" rows="1"></textarea>
                <button type="submit" id="send-button" class="bg-indigo-600 text-white p-3 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition disabled:bg-indigo-300 disabled:cursor-not-allowed">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send"><path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/></svg>
                </button>
            </form>
        </div>
    </div>

    <!-- Receiver iframe section (initially in bookmark state) -->
    <div id="receiver-container" class="bg-white p-6 rounded-xl shadow-md border border-slate-200 mt-4 state-bookmark">
        <div class="receiver-header h-10 flex items-center justify-between px-4"> 
            <button id="refresh-receiver-button" class="text-white hover:text-gray-300">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-refresh-cw">
                    <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
                    <path d="M21 3v5h-5"/>
                    <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
                    <path d="M3 21v-5h5"/>
                </svg>
            </button>
            <button id="close-receiver-button" class="text-white hover:text-gray-300">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x">
                    <path d="M18 6 6 18"/>
                    <path d="m6 6 12 12"/>
                </svg>
            </button>
        </div>
        <iframe id="receiver-iframe" src="http://localhost:5400/" title="Receiver Server" class="w-full h-full border-none rounded-lg"></iframe>
    </div>

    <!-- Iframe Bookmark Tab -->
    <div id="iframe-bookmark-tab" class="z-50">
        <button id="open-receiver-button" class="flex items-center justify-center text-white w-full h-full">
            <!-- Icon Phân tích Dữ liệu (hiển thị ở trạng thái bookmark) -->
            <svg id="data-coffee-icon" width="32" height="32" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
                <g>
                    <!-- Phin cà phê -->
                    <path d="M14 28 L50 28 L48 50 L16 50 Z" />
                    <rect x="12" y="24" width="40" height="4" rx="2" />
                    <rect x="28" y="16" width="8" height="8" rx="2" />
                    <rect x="10" y="50" width="44" height="4" rx="2" />
                    <!-- Hơi nóng bốc lên -->
                    <path class="coffee-steam steam-1" d="M24 22 Q 28 16, 32 22" fill="none" />
                    <path class="coffee-steam steam-2" d="M32 22 Q 36 16, 40 22" fill="none" />
                    <path class="coffee-steam steam-3" d="M28 20 Q 32 14, 36 20" fill="none" />
                </g>
            </svg>
            <!-- Icon Quyển sổ (hiển thị ở các trạng thái khác) -->
            <svg id="notebook-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-notebook hidden">
                <path d="M2 6h4" />
                <path d="M2 10h4" />
                <path d="M2 14h4" />
                <path d="M2 18h4" />
                <rect width="16" height="20" x="4" y="2" rx="2" />
                <path d="M16 2v20" />
            </svg>
        </button>
    </div>

    <script type="module">


        // Renamed variables for clarity in English
        const chatForm = document.getElementById('chat-form'); 
        const chatInput = document.getElementById('chat-input'); 
        const sendButton = document.getElementById('send-button'); 
        const chatContainer = document.getElementById('chat-container'); 
        
        const geminiApiKeyInput = document.getElementById('gemini-api-key'); 
        const googleApiKeyInput = document.getElementById('google-api-key'); 
        const googleCxInput = document.getElementById('google-cx');
        const showKeyButton = document.getElementById('show-key-button'); 
        const apiKeySection = document.getElementById('api-key-section'); 
        const searchModeSelector = document.getElementById('search-mode-selector'); 
        const suggestionsContainer = document.getElementById('suggestions-container'); 
        
        // New elements to control the receiver iframe
        const receiverContainer = document.getElementById('receiver-container'); 
        const receiverFullscreenHeader = receiverContainer.querySelector('.receiver-header'); 
        const iframeBookmarkTab = document.getElementById('iframe-bookmark-tab'); 
        const receiverIframe = document.getElementById('receiver-iframe'); 
        const openReceiverButton = document.getElementById('open-receiver-button'); 

        // Suggest Information Extraction button
        const suggestExtractionButton = document.getElementById('suggest-extraction-button'); 
        
        // THAY ĐỔI: Lấy element của các icon mới
        const dataCoffeeIcon = document.getElementById('data-coffee-icon');
        const notebookIcon = document.getElementById('notebook-icon');


        let citationData = []; // Array to store structured citation data
        let uniqueCounter = 0; // Counter for unique IDs, used for citation download button
        let sstData = [];
        let sstSchema = [
            { field: "ID", headerName: "ID" },
            { field: "Update Status", headerName: "Price Updated?" }, 
            { field: "Product", headerName: "Product Name" }, 
            { field: "Brand", headerName: "Brand Name" }, 
            { field: "Listed Price (VND)", headerName: "Listed Price (VND)" }, 
            { field: "Date", headerName: "Data Date" }, 
            { field: "Shipping Fee (VND)", headerName: "Shipping Fee (VND)" }, 
            { field: "Freeship Threshold (VND)", headerName: "Freeship Threshold (VND)" }, 
            { field: "Source", headerName: "Citation Source" }, 
            { field: "Product Type", headerName: "Coffee Type" }, 
            { field: "Net Weight", headerName: "Net Weight" }, 
            { field: "Location", headerName: "Sell Location" }, 
            { field: "Link", headerName: "Product Link" }, 
            { field: "HTML", headerName: "HTML Selector (Price)" }, 
            { field: "E-commerce", headerName: "E-commerce Platform" } 
        ];

        let currentIframeState = 'bookmark'; // Initial state

        let isDragging = false;
        let startX;
        let initialIframeWidth; // Store iframe width at drag start
        let selectedMode = searchModeSelector.value; 
        const PARTIAL_WIDTH_VW = 20; // 1/5 viewport width
        const FULLSCREEN_THRESHOLD_VW = 30; // If dragged past 30vw, switch to fullscreen
        const BOOKMARK_THRESHOLD_VW = 5; // If dragged below 5vw, switch to bookmark

        // Define a schema for the analysis response
        const analysisResponseSchema = {
            type: "OBJECT",
            properties: {
                "queries": {
                    type: "ARRAY",
                    items: { type: "STRING" }
                },
                "output_schema": {
                    type: "ARRAY",
                    items: { type: "STRING" }
                },
                "analysis": { type: "STRING" }
            },
            propertyOrdering: ["queries", "output_schema", "analysis"]
        };

        // Define a schema for the simulated search results
        const searchResultsSchema = {
            type: "ARRAY",
            items: {
                type: "OBJECT",
                properties: {
                    "title": { "type": "STRING" },
                    "snippet": { "type": "STRING" },
                    "url": { "type": "STRING" }
                },
                propertyOrdering: ["title", "snippet", "url"]
            }
        };

        // Function to update iframe state
        function setIframeState(newState, disableTransition = false) { 
            console.log(`Setting iframe state to: ${newState}, disableTransition: ${disableTransition}`);
            if (disableTransition) {
                receiverContainer.style.transition = 'none';
                iframeBookmarkTab.style.transition = 'none';
            } else {
                receiverContainer.style.transition = 'width 0.3s ease-in-out, padding 0.3s ease-in-out, left 0.3s ease-in-out, right 0.3s ease-in-out';
                iframeBookmarkTab.style.transition = 'right 0.3s ease-in-out, background-color 0.3s ease-in-out, opacity 0.3s ease-in-out';
            }

            receiverContainer.classList.remove('state-bookmark', 'state-partial', 'state-fullscreen');
            receiverContainer.classList.add(`state-${newState}`);
            currentIframeState = newState;
            
            // THAY ĐỔI: Logic chuyển đổi icon
            if (newState === 'bookmark') {
                dataCoffeeIcon.classList.remove('hidden');
                notebookIcon.classList.add('hidden');
            } else {
                dataCoffeeIcon.classList.add('hidden');
                notebookIcon.classList.remove('hidden');
            }


            // Handle fullscreen header display
            if (newState === 'fullscreen') {
                receiverFullscreenHeader.style.display = 'flex';
                iframeBookmarkTab.style.display = 'none'; // Hide bookmark tab in fullscreen
                receiverContainer.style.width = '100vw'; // Set width to 100vw for fullscreen
                receiverContainer.style.left = '0'; // Ensure it starts from left
                receiverContainer.style.right = '0'; // Ensure it extends to the right
                receiverContainer.style.padding = '0'; // Remove padding in fullscreen
            } else if (newState === 'partial') { // partial or bookmark
                receiverFullscreenHeader.style.display = 'none';
                iframeBookmarkTab.style.display = 'flex'; // Show bookmark tab otherwise
                iframeBookmarkTab.style.right = `${PARTIAL_WIDTH_VW}vw`; // Bookmark tab sticks to left edge of iframe (relative to screen right)
                receiverContainer.style.width = `${PARTIAL_WIDTH_VW}vw`; // Ensure iframe width is also set for partial state
                receiverContainer.style.left = 'auto'; // Ensure it's on the right
                receiverContainer.style.right = '0';
                receiverContainer.style.padding = '1rem'; // Default padding for partial
            } else if (newState === 'bookmark') {
                receiverFullscreenHeader.style.display = 'none';
                iframeBookmarkTab.style.display = 'flex'; // Show bookmark tab otherwise
                iframeBookmarkTab.style.right = '0'; // Back to edge
                receiverContainer.style.width = '0'; // Ensure iframe width is 0 for bookmark state
                receiverContainer.style.left = 'auto'; // Ensure it's on the right
                receiverContainer.style.right = '0';
                receiverContainer.style.padding = '0'; // No padding when hidden
            }

            // Ensure iframe content only visible when not in bookmark state
            if (newState === 'bookmark') {
                receiverIframe.style.opacity = '0';
                receiverIframe.style.pointerEvents = 'none'; /* Disable interaction */
            } else {
                receiverIframe.style.opacity = '1';
                receiverIframe.style.pointerEvents = 'auto'; /* Enable interaction */
            }
            lucide.createIcons(); // Re-render icons after DOM manipulation
        }


        // Load keys from local storage if available
        geminiApiKeyInput.value = localStorage.getItem('geminiApiKey') || '';
        googleApiKeyInput.value = localStorage.getItem('googleApiKey') || '';
        googleCxInput.value = localStorage.getItem('googleCx') || '';
        searchModeSelector.value = localStorage.getItem('searchMode') || 'limited'; // Load selected mode
        selectedMode = searchModeSelector.value; 

        // Save keys and mode to local storage on change
        geminiApiKeyInput.addEventListener('input', () => localStorage.setItem('geminiApiKey', geminiApiKeyInput.value));
        googleApiKeyInput.addEventListener('input', () => localStorage.setItem('googleApiKey', googleApiKeyInput.value));
        googleCxInput.addEventListener('input', () => localStorage.setItem('googleCx', googleCxInput.value));
        searchModeSelector.addEventListener('change', () => {
            localStorage.setItem('searchMode', searchModeSelector.value);
            selectedMode = searchModeSelector.value; 
        });

        showKeyButton.addEventListener('click', () => {
            apiKeySection.classList.toggle('hidden');
        });

        // Function to get yesterday's date in English format
        function getYesterdayDateEnglish() {
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1); // Subtract 1 day to get yesterday
            
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            const formatter = new Intl.DateTimeFormat('en-US', options);
            let dateString = formatter.format(yesterday); // Get formatted date string

            return dateString;
        }

        // Function to display suggestions
        function displaySuggestions(suggestions) {
            // Clear existing suggestions, but keep the new "Suggest Information Extraction" button
            const existingButton = suggestExtractionButton.cloneNode(true); // Clone the button
            suggestionsContainer.innerHTML = ''; // Clear all
            suggestionsContainer.appendChild(existingButton); // Add the button back

            suggestions.forEach(suggestion => {
                const button = document.createElement('button');
                button.className = 'suggestion-btn';
                button.textContent = suggestion;
                button.addEventListener('click', () => {
                    chatInput.value = suggestion;
                    // REMOVED: chatForm.dispatchEvent(new Event('submit')); // Submit form
                });
                suggestionsContainer.appendChild(button);
            });
        }
        
        /**
         * Suggests optimized questions for structured SST information extraction from Gemini.
         * @param {string} originalUserQuestion - The user's original question.
         * @param {string} geminiApiKey - The Gemini API key for model calls.
         * @param {object} analysisResponse - The analysis response from the initial Gemini call.
         * @returns {Promise<string>} A Promise that resolves to the optimized question.
         */
        async function suggestSSTQuestion(originalUserQuestion, geminiApiKey, analysisResponse) {
            const sstSchemaDescription = `
                Description of SST data columns:
                - "ID": Unique identifier for each record (keep it empty by now).
                - "Update Status": Status of price update (keep it empty by now).
                - "Product": Name or brief description of the product.
                - "Brand": Manufacturer/brand name of the product.
                - "Listed Price (VND)": Public price in VND.
                - "Date": Date information was added to the system (keep it empty by now).
                - "Shipping Fee (VND)": Estimated shipping cost in VND.
                - "Freeship Threshold (VND)": Minimum order value for free shipping in VND.
                - "Source": Origin of information (website, store).
                - "Product Type": Product classification (e.g., "robusta", "arabica", "blend").
                - "Net Weight": The net weight accompanied by the corresponding unit of measurement (pound, kg).
                - "Location": Area where the product is available or price was collected.
                - "Link": Detailed product URL.
                - "HTML": CSS Selector/XPath to locate the price on the webpage.
                - "E-commerce": E-commerce Platform (Shopee, Lazada).
            `;

            const prompt = `
                You are a professional AI assistant, capable of self-assessment and optimizing user questions to obtain structured data.
                Your task is to review the user's original question and its current AI-returned analysis information (search queries, desired output schema) to create a new, concise, natural question in the user's native language.
                This new question must retain the user's original intent and be designed to maximize the AI model's ability to return information in a table format, strictly adhering to the given SST data schema. Specifically, the suggested question should include phrases like 'structured data', 'in table format', or refer to price/product information fields from the SST schema to encourage structured responses.
                Use the detailed description of each SST column to understand their semantics.
                Ensure the suggestion is consistent with the generated search queries.

                SST schema and description:
                ${sstSchemaDescription}

                User's original question: "${originalUserQuestion}"
                Generated search queries: ${JSON.stringify(analysisResponse.queries)}
                Desired output schema (if any): ${JSON.stringify(analysisResponse.output_schema)}
                Internal analysis: ${analysisResponse.analysis || 'No analysis.'}

                Please return only the new question, without any other text or explanation.
            `;

            try {
                const optimizedQuestion = await callGemini(prompt, geminiApiKey, false);
                return optimizedQuestion.trim();
            } catch (error) {
                console.error("Error generating SST question suggestion:", error);
                return ""; // Return empty string if error
            }
        }

        let currentQuestionSuggestion = ''; // Variable to store the current suggestion

        suggestExtractionButton.addEventListener('click', async () => {

            const geminiApiKey = geminiApiKeyInput.value;
            const currentInput = chatInput.value.trim(); // Get current value of input field

            if (!geminiApiKey) { // Check if Gemini API key is missing
                if (selectedMode !== 'quota' && selectedMode !== 'quota-backend') {
                    displayMessage(
                        `<p class="font-semibold text-red-600">Gemini API Key Error</p><p>Please provide your Gemini API key to use the suggestion feature.</p>`, 
                        'system_error'
                    );
                    apiKeySection.classList.remove('hidden'); // Show API key section
                    geminiApiKeyInput.focus(); // Focus on Gemini API key input
                    return;
                }
            }

            if (currentQuestionSuggestion) { // If a suggestion is currently displayed on the button
                chatInput.value = currentQuestionSuggestion; // Populate the input field
                currentQuestionSuggestion = ''; // Clear stored suggestion
                suggestExtractionButton.textContent = 'Suggest Information Extraction'; // Reset button text
                suggestExtractionButton.classList.remove('bg-blue-500', 'hover:bg-blue-600', 'text-white');
                suggestExtractionButton.classList.add('bg-gray-300', 'hover:bg-gray-400');
            } else { // No suggestion currently displayed on the button
                if (!currentInput) { // If user input is empty, don't generate suggestion
                    displayMessage(
                        `<p class="font-semibold text-orange-600">Please enter a question to get suggestions.</p>`,
                        'system_warning'
                    );
                    return; // Exit without doing anything
                }

                // Otherwise, generate a new suggestion based on currentInput
                suggestExtractionButton.textContent = 'Generating suggestion...';
                suggestExtractionButton.disabled = true;
                suggestExtractionButton.classList.remove('bg-gray-300', 'hover:bg-gray-400');
                suggestExtractionButton.classList.add('bg-blue-300'); // Indicate loading with light blue

                try {
                    // Temporarily call analysis to get search queries for context
                    const yesterdayDate = getYesterdayDateEnglish();
                    const analysisPromptForSuggestion = `
                        You are a professional research assistant.
                        Your task is to analyze the user's question and generate 3 to 5 Google search queries to gather information.
                        If the user's question specifies a particular output data structure, extract these column headers.
                        Yesterday was: "${yesterdayDate}".
                        
                        Return a valid JSON object with the following keys: "queries", "output_schema", "analysis".
                        - "queries": an array of search query strings.
                        - "output_schema": an array of column header strings if the user requests a specific structure (e.g., "coffee prices in a table"), otherwise an empty array.
                        - "analysis": (Optional) A brief string describing how you analyzed the question and your search/extraction strategy, especially if the question is ambiguous or complex.

                        
                        Do not add any other text or explanation besides the JSON object.
                        
                        User question: "${currentInput}"
                    `;
                    const tempAnalysisResponse = await callGemini(analysisPromptForSuggestion, geminiApiKey, true, analysisResponseSchema);

                    const suggestion = await suggestSSTQuestion(currentInput, geminiApiKey, tempAnalysisResponse);
                    if (suggestion) {
                        currentQuestionSuggestion = suggestion;
                        suggestExtractionButton.textContent = suggestion;
                        suggestExtractionButton.classList.remove('bg-blue-300');
                        suggestExtractionButton.classList.add('bg-blue-500', 'hover:bg-blue-600', 'text-white');
                    } else {
                        suggestExtractionButton.textContent = 'No suggestion available';
                        suggestExtractionButton.classList.remove('bg-blue-300');
                        suggestExtractionButton.classList.add('bg-gray-300', 'hover:bg-gray-400');
                    }
                } catch (error) {
                    console.error("Error generating suggestion:", error);
                    displayMessage(
                        `<p class="font-semibold text-red-600">Error generating suggestion:</p><p>${error.message}</p>`, 
                        'system_error'
                    );
                    suggestExtractionButton.textContent = 'Suggest Information Extraction'; // Reset on error
                    suggestExtractionButton.classList.remove('bg-blue-300');
                    suggestExtractionButton.classList.add('bg-gray-300', 'hover:bg-gray-400');
                } finally {
                    suggestExtractionButton.disabled = false;
                }
            }
        });

        // Add keydown listener to chatInput for Enter and Ctrl+Enter
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if (e.shiftKey) {
                    // Shift + Enter: Add a new line (default browser behavior, no need to preventDefault)
                } else if (e.ctrlKey || e.metaKey) { // Ctrl+Enter or Cmd+Enter
                    e.preventDefault(); // Prevent new line
                    suggestExtractionButton.click(); // Trigger suggestion button click
                } else {
                    e.preventDefault(); // Prevent new line
                    chatForm.dispatchEvent(new Event('submit')); // Submit the form
                }
            }
        });


        chatForm.addEventListener('submit', async (e) => { 
            e.preventDefault();
            const userInput = chatInput.value.trim(); 
            if (!userInput) return;

            const geminiApiKey = geminiApiKeyInput.value; 
            const googleApiKey = googleApiKeyInput.value; 
            const googleCx = googleCxInput.value;
            selectedMode = searchModeSelector.value; 

            console.log('API Key Debug Check:');
            console.log('googleApiKey:', googleApiKey);
            console.log('googleCx:', googleCx);
            console.log('selectedMode:', selectedMode);

            // Check if Google Search API keys are missing
            if (!googleApiKey || !googleCx) {
                // If the user tries to use a mode that requires Google Search API keys
                if (selectedMode !== 'quota' && selectedMode !== 'quota-backend') {
                    displayMessage( 
                        `<p class="font-semibold text-red-600">Google Search API Key Error</p><p>To use "${selectedMode}" mode, you need to provide both your Google Search API key and Search Engine ID (CX).</p><p class="mt-2">Do you want to switch to "Quota" or "Quota (Back-end)" mode to continue without a Google Search API key? Please select one of these modes from the dropdown list.</p>`, 
                        'system_error'
                    );
                    apiKeySection.classList.remove('hidden'); 
                    googleApiKeyInput.focus(); 
                    setLoadingState(false); 
                    return;
                }
                // If selectedMode IS 'quota' or 'quota-backend', then it's fine to proceed without Google Search API keys.
                // No explicit message needed here, as this is expected behavior.
            }

            // Reset citation data for a new request
            citationData = []; 

            chatInput.value = '';
            setLoadingState(true); 
            displayMessage(userInput, 'user'); 

            try {
                const yesterdayDate = getYesterdayDateEnglish(); 

                // --- STEP 1: ANALYZE QUESTION AND DETERMINE SCHEMA ---
                const thinkingMessage = displayMessage('', 'system_thinking', true); 
                updateMessage(thinkingMessage, ` 
                    <div class="flex items-center gap-2">
                        <span class="dot-effect">Analyzing question, planning search, and determining data structure...</span>
                    </div>
                `);

                // Prompt updated to identify desired output schema and potentially clarify
                const analysisPrompt = `
                    You are a professional AI research assistant, capable of self-assessment and optimizing processes.
                    Your task is to analyze the user's question and generate 3 to 5 simple and effective Google search queries to gather the necessary information to provide a comprehensive answer.
                    
                    **Self-assessment and Optimization Principles:**
                    - If the user's question specifies a particular output data structure, extract these column headers.
                    - If the question seems ambiguous (e.g., "AAA"), suggest potential meanings and generate queries for each meaning, or if possible, ask the user for clarification. (Note: In the current environment, it's difficult to directly ask the user, prioritize generating queries for common meanings).
                    - Ensure search queries are broad enough to cover the topic but also specific enough to return relevant results.
                    - Based on the provided SST schema, generate 2-3 related SST data questions that the user might ask to receive similar structured data. These suggestions must be natural questions in the user's native language.

                    If the user's question is in English, your search queries must also be in English.
                    If the user's question refers to a specific time period (e.g., "yesterday", "last week", "year 2023"), use this date information in your queries.
                    Yesterday was: "${yesterdayDate}".
                    
                    Return a valid JSON object with the following keys:
                    - "queries": an array of search query strings.
                    - "output_schema": an array of column header strings if the user requests a specific structure (e.g., "coffee prices in a table"), otherwise an empty array.
                    - "analysis": (Optional) A brief string describing how you analyzed the question and your search/extraction strategy, especially if the question is ambiguous or complex.

                    Do not add any other text or explanation besides the JSON object.

                    Current SST schema (if any): ${JSON.stringify(sstSchema.map(s => s.field))}

                    User question: "${userInput}"
                `;

                const analysisResponse = await callGemini(analysisPrompt, geminiApiKey, true, analysisResponseSchema); 
                console.log("analysisResponse", analysisResponse);
                const searchQueries = analysisResponse.queries; 
                // Ensure output_schema always contains SST fields if user requested a table
                let desiredSchemaHeaders = analysisResponse.output_schema; 
                if (!desiredSchemaHeaders) {
                    desiredSchemaHeaders = sstSchema.map(s => s.field);
                }
                const analysisText = analysisResponse.analysis || ''; 

                let queriesHtml = searchQueries.map(q => `<li><code class="bg-slate-200 px-1 py-0.5 rounded">${q}</code></li>`).join(''); 
                let schemaHtml = ''; 
                if (desiredSchemaHeaders && desiredSchemaHeaders.length > 0) {
                    schemaHtml = `<p class="font-semibold mt-3 mb-2">Desired data structure:</p><ul class="list-disc list-inside mt-2 space-y-1">${desiredSchemaHeaders.map(h => `<li><code class="bg-slate-200 px-1 py-0.5 rounded">${h}</code></li>`).join('')}</ul>`;
                }
                let analysisHtml = analysisText ? `<p class="font-semibold mt-3 mb-2">Internal analysis:</p><p class="text-sm italic">${analysisText}</p>` : ''; 

                updateMessage(thinkingMessage, `
                    <p class="font-semibold mb-2">Search Plan:</p>
                    <p>To answer your question, I will search for the following topics:</p>
                    <ul class="list-disc list-inside mt-2 space-y-1">${queriesHtml}</ul>
                    ${schemaHtml}
                    ${analysisHtml}
                `);

                // --- Optimize SST question suggestion ---
                const optimizedSSTQuestion = await suggestSSTQuestion(userInput, geminiApiKey, analysisResponse); // Pass analysisResponse here
                if (optimizedSSTQuestion) {
                    // Update the suggestion button, not the general suggestions
                    currentQuestionSuggestion = optimizedSSTQuestion;
                    suggestExtractionButton.textContent = optimizedSSTQuestion;
                    suggestExtractionButton.classList.remove('bg-gray-300', 'hover:bg-gray-400');
                    suggestExtractionButton.classList.add('bg-blue-500', 'hover:bg-blue-600', 'text-white');
                }


                // --- STEP 2: PERFORM WEB SEARCH / SCRAPING / GEMINI DATA GENERATION AND EXTRACTION ---
                const searchMessage = displayMessage('', 'system_searching', true); 
                updateMessage(searchMessage, `
                    <div class="flex items-center gap-2">
                        <span class="dot-effect">Searching/scraping web information and extracting data...</span>
                    </div>
                `);
                
                let rawSearchResults = []; 
                const processedUrls = new Set(); 

                if (selectedMode === 'quota-backend') {
                    // Quota (Back-end) mode: Use Gemini to simulate search results and scraped content
                    updateMessage(searchMessage, `
                        <div class="flex items-center gap-2">
                            <i data-lucide="gem" class="w-4 h-4 text-slate-500"></i>
                            <span class="dot-effect">Generating simulated search results and page content with Gemini (Quota - Back-end Mode)...</span>
                        </div>
                    `);
                    let sourceCounter = 0; 
                    for (const query of searchQueries) { 
                        // Simulate Google Search results (title, snippet, URL)
                        const geminiSearchPrompt = `
                            You are a search engine. Please provide 1 to 2 most relevant search results for the query "${query}". Each result must include a title, a short snippet, and a hypothetical URL. Format your response as a JSON array like this:
                            [
                              {
                                "title": "Result Title 1",
                                "snippet": "This is a brief summary of the first search result.",
                                "url": "https://example.com/page1"
                              }
                            ]
                            Ensure URLs are unique and plausible.
                        `;
                        const geminiGeneratedSearchResults = await callGemini(geminiSearchPrompt, geminiApiKey, true, searchResultsSchema); 

                        if (geminiGeneratedSearchResults && Array.isArray(geminiGeneratedSearchResults)) {
                            for (const item of geminiGeneratedSearchResults) { 
                                if (processedUrls.has(item.url)) {
                                    console.log(`Simulated URL already processed, skipping: ${item.url}`);
                                    continue;
                                }
                                processedUrls.add(item.url);

                                sourceCounter++;
                                const currentSourceId = `S${sourceCounter}`; 
                                updateMessage(searchMessage, `
                                    <div class="flex items-center gap-2">
                                        <i data-lucide="file-text" class="w-4 h-4 text-slate-500"></i>
                                        <span class="dot-effect">Generating simulated page content [${currentSourceId}] : <a href="${item.url}" target="_blank" class="text-indigo-600 hover:underline">${item.url.substring(0, 50)}...</a></span>
                                    </div>
                                `);

                                // Simulate scraped content with Gemini
                                const geminiScrapePrompt = `
                                    You are a webpage content simulator. Based on the title, snippet, and hypothetical URL of a search result, generate a longer text (around 300 to 500 words) that looks like the full content of a related webpage. This content should expand on the information from the snippet and be plausible given the title and URL.
                                    
                                    User's original question: "${userInput}"
                                    Search query: "${query}"
                                    Search result title: "${item.title}"
                                    Search result snippet: "${item.snippet}"
                                    Hypothetical URL: "${item.url}"

                                    Please return only the simulated text content, no other explanations.
                                `;
                                const simulatedContent = await callGemini(geminiScrapePrompt, geminiApiKey, false); 

                                // Extract structured information from simulated content
                                const extractedInfo = await extractStructuredInformation( 
                                    userInput,
                                    query, // Use original query for extraction context
                                    simulatedContent,
                                    item.url,
                                    currentSourceId,
                                    geminiApiKey,
                                    desiredSchemaHeaders
                                );
                                
                                if (extractedInfo) {
                                    citationData.push(extractedInfo); 
                                    const displaySummary = extractedInfo['Summary'] || item.snippet || 'Could not summarize main content for this source.'; 
                                    displayMessage(`
                                        <p class="font-semibold mb-1">Observed simulated page [${extractedInfo.ID || currentSourceId}] :</p>
                                        <p class="text-sm">${displaySummary}</p>
                                        <p class="text-xs text-slate-500 mt-1">Source: <a href="${extractedInfo['Citation Source'] || item.url}" target="_blank" class="text-indigo-600 hover:underline">${extractedInfo['Citation Source'] || item.url}</a></p>
                                    `, 'system_thinking');
                                    rawSearchResults.push({ 
                                        title: extractedInfo['Summary'] || `Content of: ${item.url}`,
                                        link: item.url,
                                        snippet: extractedInfo['Summary'] || simulatedContent.substring(0, 200),
                                        id: extractedInfo.ID || currentSourceId
                                    });
                                } else {
                                    displayMessage(`
                                        <p class="font-semibold text-red-600">Extraction Error [${currentSourceId}] :</p>
                                        <p class="text-sm">Could not extract structured information from simulated content of <a href="${item.url}" target="_blank" class="text-indigo-600 hover:underline">${item.url.substring(0, 50)}...</a>.</p>
                                    `, 'system_error');
                                }
                                await new Promise(resolve => setTimeout(resolve, 500)); // Small delay
                            }
                        }
                        await new Promise(resolve => setTimeout(resolve, 200)); // Small delay between queries
                    }

                } else if (selectedMode === 'quota') {
                    // Quota mode: Use Gemini to generate simulated search results
                    updateMessage(searchMessage, `
                        <div class="flex items-center gap-2">
                            <i data-lucide="gem" class="w-4 h-4 text-slate-500"></i>
                            <span class="dot-effect">Generating search results with Gemini (Quota Mode)...</span>
                        </div>
                    `);
                    const geminiSearchPrompt = `
                        You are a search engine. Please provide 3 to 5 most relevant search results for the query "${userInput}". Each result must include a title, a short snippet, and a hypothetical URL. Format your response as a JSON array like this:
                        [
                          {
                            "title": "Result Title 1",
                            "snippet": "This is a brief summary of the first search result.",
                            "url": "https://example.com/page1"
                          },
                          {
                            "title": "Result Title 2",
                            "snippet": "Another snippet for the second result, providing more information.",
                            "url": "https://anothersite.org/document2"
                          }
                        ]
                        Ensure URLs are unique and plausible.
                    `;
                    const geminiGeneratedResults = await callGemini(geminiSearchPrompt, geminiApiKey, true, searchResultsSchema); 

                    let sourceCounter = 0; 
                    if (geminiGeneratedResults && Array.isArray(geminiGeneratedResults)) {
                        for (const item of geminiGeneratedResults) { 
                            sourceCounter++;
                            const currentSourceId = `S${sourceCounter}`; 
                            // Process Gemini-generated item as a source
                            const extractedInfo = await extractStructuredInformation( 
                                userInput,
                                userInput, // Use user input as query context for extraction
                                item.snippet,
                                item.url,
                                currentSourceId,
                                geminiApiKey,
                                desiredSchemaHeaders
                            );

                            if (extractedInfo) {
                                citationData.push(extractedInfo); 
                                const displaySummary = extractedInfo['Summary'] || item.snippet || 'Could not summarize main content for this source.'; 
                                rawSearchResults.push({ 
                                    title: item.title,
                                    link: item.link,
                                    snippet: item.snippet,
                                    id: extractedInfo.ID || currentSourceId
                                });
                            } else {
                                console.warn(`Could not extract structured information from Gemini result: ${item.url}`);
                                rawSearchResults.push({ // Still add to rawSearchResults even if extraction fails
                                    title: item.title,
                                    link: item.link,
                                    snippet: item.snippet,
                                    id: currentSourceId
                                });
                            }
                        }
                    } else {
                        displayMessage(`
                            <p class="font-semibold text-red-600">Gemini Quota Mode Error:</p>
                            <p class="text-sm">Gemini did not return valid simulated search results.</p>
                        `, 'system_error');
                    }

                } else if (selectedMode === 'backend') {
                    // Backend mode: Fetch URLs from Google Search, then scrape each URL
                    let sourceCounter = 0; 
                    for (const query of searchQueries) { 
                        updateMessage(searchMessage, `
                            <div class="flex items-center gap-2">
                                <i data-lucide="search" class="w-4 h-4 text-slate-500"></i>
                                <span class="dot-effect">Searching URLs for: "${query}"...</span>
                            </div>
                        `);
                        const googleResults = await callGoogleSearch(query, googleApiKey, googleCx); 
                        if (googleResults && googleResults.items) {
                            const urlsToScrape = googleResults.items.slice(0, 3).map(item => item.link); 
                            for (const url of urlsToScrape) {
                                sourceCounter++;
                                const currentSourceId = `S${sourceCounter}`; 
                                
                                if (processedUrls.has(url)) {
                                    console.log(`URL already processed, skipping: ${url}`);
                                    continue;
                                }
                                processedUrls.add(url);

                                // Check for PDFs or other non-HTML files before attempting to scrape
                                const urlExtension = url.split('.').pop().toLowerCase(); 
                                const nonHtmlExtensions = ['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'zip', 'rar', '7z', 'jpg', 'jpeg', 'png', 'gif', 'mp3', 'mp4', 'avi', 'mov']; 
                                const troublesomeDomains = ['youtube.com', 'facebook.com']; 
                                let urlDomain; 
                                try {
                                    urlDomain = new URL(url).hostname;
                                } catch (e) {
                                    console.warn(`Encountered invalid URL: ${url}. Skipping.`);
                                    displayMessage(`
                                        <p class="font-semibold text-orange-600">Skipping scrape [${currentSourceId}] :</p>
                                        <p class="text-sm">Invalid URL: <a href="${url}" target="_blank" class="text-indigo-600 hover:underline">${url.substring(0, 50)}...</a>. Skipping source.</p>
                                    `, 'system_warning');
                                    continue; // Move to next URL
                                }


                                if (nonHtmlExtensions.includes(urlExtension)) {
                                    displayMessage(`
                                        <p class="font-semibold text-orange-600">Skipping scrape [${currentSourceId}] :</p>
                                        <p class="text-sm">Unsupported file type ".${urlExtension}" at <a href="${url}" target="_blank" class="text-indigo-600 hover:underline">${url.substring(0, 50)}...</a>. Please try "Limited" or "Unlimited" mode if you want to use snippets from Google Search.</p>
                                    `, 'system_warning'); // Use warning message for skipped files
                                    continue; // Move to next URL
                                } else if (troublesomeDomains.some(domain => urlDomain.includes(domain))) {
                                    displayMessage(`
                                        <p class="font-semibold text-orange-600">Skipping scrape [${currentSourceId}] :</p>
                                        <p class="text-sm">Websites from <a href="${url}" target="_blank" class="text-indigo-600 hover:underline">${urlDomain}</a> often block automated scrapers. Please try "Limited" or "Unlimited" mode if you want to use snippets from Google Search for this source.</p>
                                    `, 'system_warning');
                                    continue; // Move to next URL
                                }

                                updateMessage(searchMessage, `
                                    <div class="flex items-center gap-2">
                                        <i data-lucide="globe" class="w-4 h-4 text-slate-500"></i>
                                        <span class="dot-effect">Scraping [${currentSourceId}] : <a href="${url}" target="_blank" class="text-indigo-600 hover:underline">${url.substring(0, 50)}...</a></span>
                                    </div>
                                `);
                                const scrapedData = await callBackendScraper(url); 
                                if (scrapedData && scrapedData.content) {
                                    // Extract structured information using Gemini, passing the desired schema
                                    const extractedInfo = await extractStructuredInformation( 
                                        userInput,
                                        query,
                                        scrapedData.content,
                                        url,
                                        currentSourceId,
                                        geminiApiKey,
                                        desiredSchemaHeaders
                                    );
                                    
                                    if (extractedInfo) {
                                        citationData.push(extractedInfo); 
                                        const displaySummary = extractedInfo['Summary'] || scrapedData.content.substring(0, 200) || 'Could not summarize main content for this source.'; 
                                        displayMessage(`
                                            <p class="font-semibold mb-1">Observed page [${extractedInfo.ID || currentSourceId}] :</p>
                                            <p class="text-sm">${displaySummary}</p>
                                            <p class="text-xs text-slate-500 mt-1">Source: <a href="${extractedInfo['Citation Source'] || url}" target="_blank" class="text-indigo-600 hover:underline">${extractedInfo['Citation Source'] || url}</a></p>
                                        `, 'system_thinking');
                                        rawSearchResults.push({ 
                                            title: extractedInfo['Summary'] || `Content of: ${url}`,
                                            link: url,
                                            snippet: extractedInfo['Summary'] || scrapedData.content.substring(0, 200), // Use summary or part of content as snippet
                                            id: extractedInfo.ID || currentSourceId
                                        });
                                    } else {
                                        displayMessage(`
                                            <p class="font-semibold text-red-600">Extraction Error [${currentSourceId}] :</p>
                                            <p class="text-sm">Could not extract structured information from <a href="${url}" target="_blank" class="text-indigo-600 hover:underline">${url.substring(0, 50)}...</a>.</p>
                                    `, 'system_error');
                                    }
                                } else {
                                    displayMessage(`
                                        <p class="font-semibold text-red-600">Scraping Error [${currentSourceId}] :</p>
                                        <p class="text-sm">Could not scrape content from <a href="${url}" target="_blank" class="text-indigo-600 hover:underline">${url.substring(0, 50)}...</a>. Error: ${scrapedData.error || 'Unknown error'}</p>
                                    `, 'system_error');
                                    console.warn(`Could not scrape URL: ${url}. Error: ${scrapedData.error || 'Unknown error'}`);
                                }
                                await new Promise(resolve => setTimeout(resolve, 500)); // Small delay
                            }
                        }
                    }

                } else {
                    // Limited/Unlimited mode: Use Google Custom Search API for snippets
                    let sourceCounter = 0; 
                    for (const query of searchQueries) { 
                        updateMessage(searchMessage, `
                            <div class="flex items-center gap-2">
                                <i data-lucide="search" class="w-4 h-4 text-slate-500"></i>
                                <span class="dot-effect">Searching: "${query}"...</span>
                            </div>
                        `);
                        const results = await callGoogleSearch(query, googleApiKey, googleCx); 
                        if (results && results.items) {
                            let snippetsToProcess; 
                            if (selectedMode === 'limited') {
                                snippetsToProcess = results.items.slice(0, 3); 
                            } else { // 'unlimited' mode
                                snippetsToProcess = results.items; 
                            }
                            
                            for (const item of snippetsToProcess) { 
                                if (processedUrls.has(item.link)) {
                                    console.log(`URL already processed, skipping: ${item.link}`);
                                    continue;
                                }
                                processedUrls.add(item.link);

                                sourceCounter++;
                                const currentSourceId = `S${sourceCounter}`; 
                                // Extract structured information from snippet
                                const extractedInfo = await extractStructuredInformation( 
                                    userInput,
                                    query,
                                    item.snippet,
                                    item.link,
                                    currentSourceId,
                                    geminiApiKey,
                                    desiredSchemaHeaders 
                                );

                                if (extractedInfo) {
                                    citationData.push(extractedInfo); 
                                    const displaySummary = extractedInfo['Summary'] || item.snippet || 'Could not summarize main content for this source.'; 
                                    rawSearchResults.push({ 
                                        title: item.title,
                                        link: item.link,
                                        snippet: item.snippet,
                                        id: extractedInfo.ID || currentSourceId
                                    });
                                } else {
                                    console.warn(`Could not extract structured information from snippet: ${item.link}`);
                                    rawSearchResults.push({ // Still add to rawSearchResults even if extraction fails
                                        title: item.title,
                                        link: item.link,
                                        snippet: item.snippet,
                                        id: currentSourceId
                                    });
                                }
                            }
                        }
                        await new Promise(resolve => setTimeout(resolve, 200)); // Small delay to avoid rate limits
                    }
                }



                updateMessage(searchMessage, `
                    <div class="flex items-center gap-2 text-green-600">
                        <i data-lucide="check-circle" class="w-4 h-4"></i>
                        <span>Information collected and extracted.</span>
                    </div>
                `);

                // --- STEP 3: SYNTHESIZE AND RESPOND ---
                const synthesisMessage = displayMessage('', 'system_synthesizing', true); 
                updateMessage(synthesisMessage, `
                    <div class="flex items-center gap-2">
                        <span class="dot-effect">Synthesizing answer and citing sources...</span>
                    </div>
                `);

                // Prepare context for synthesis. Prioritize extracted data points based on desired schema.
                const context = citationData.map(c => { 
                    let contentParts = []; 
                    // If a specific schema was requested, use those fields for context
                    if (desiredSchemaHeaders && desiredSchemaHeaders.length > 0) {
                        const structuredData = {}; 
                        desiredSchemaHeaders.forEach(header => { 
                            if (c.hasOwnProperty(header)) {
                                structuredData[header] = c[header];
                            }
                        });
                        if (Object.keys(structuredData).length > 0) {
                            contentParts.push(`Structured Data: ${JSON.stringify(structuredData)}`);
                        }
                    } else { // Fallback to general structured data if no specific schema
                        if (c['Key data points'] && Object.keys(c['Key data points']).length > 0) {
                            contentParts.push(`Key Data Points: ${JSON.stringify(c['Key data points'])}`);
                        }
                        if (c['Summary']) {
                            contentParts.push(`Summary: ${c['Summary']}`);
                        } else {
                            // Fallback to original snippet if available, or just URL
                            const originalSnippet = rawSearchResults.find(rs => rs.id === c.ID)?.snippet; 
                            if (originalSnippet) {
                                contentParts.push(`Content: ${originalSnippet}`);
                            } else {
                                contentParts.push(`Content of: ${c['Citation Source']}`);
                            }
                        }
                    }
                    
                    return `Source ID: ${c.ID}\nURL: ${c['Citation Source']}\n${contentParts.join('\n')}`;
                }).join('\n\n----- New Source -----\n\n');

                // Define the new schema for synthesisPrompt response
                const synthesisResponseSchema = {
                    type: "OBJECT",
                    properties: {
                        "answer": { "type": "STRING" },
                        "column_semantics": {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    "original_name": { "type": "STRING" },
                                    "description": { "type": "STRING" },
                                    "expected_format": { "type": "STRING" },
                                    "typical_values": { type: "ARRAY", items: { type: "STRING" } }, // Changed to typical_values (array)
                                    "value_mapping": { // New field for categorical columns
                                        type: "ARRAY",
                                        items: {
                                            type: "OBJECT",
                                            properties: {
                                                "category_name": { "type": "STRING" },
                                                "keywords": { type: "ARRAY", items: { type: "STRING" } },
                                                "exclude_keywords": { type: "ARRAY", items: { type: "STRING" } },
                                                "description": { "type": "STRING" }
                                            },
                                            propertyOrdering: ["category_name", "keywords", "exclude_keywords", "description"]
                                        }
                                    }
                                }
                            }
                        }
                    },
                    propertyOrdering: ["answer", "column_semantics"]
                };

                // Final prompt to generate the answer in a general manner
                const synthesisPrompt = `
                    You are a professional AI research assistant, capable of self-assessment and optimizing output.
                    Your task is to answer the user's original question in the user's native language *only* based on the information extracted from the sources (CONTEXT).
                    
                    **Self-assessment and Optimization Principles:**
                    - By default, assume the information is complete and does not require user clarification.
                    - Ensure the answer is comprehensive, well-structured, and detailed.
                    - Your entire answer MUST be in the user's native language.
                    - Structure your answer using Markdown for better readability (headings, bold, lists).
                    - **If the user requested a specific data structure (e.g., CSV columns), present the information in a Markdown table with those columns. Ensure all requested columns are present in the table, even if values are empty.**
                    - **When using information from a specific source, cite the ID of that source immediately after the information in the format (ID: [Source ID]). For example: "Robusta coffee reached a maximum price of 50,000 VND (ID: S1)."**
                    - If the context is insufficient to fully answer the question or find specific requested information, clearly state that you could not find enough information in the provided sources. Do not invent information.
                    - Do-not use ANY information outside the provided CONTEXT.
                    - Do not mention that you are relying on the provided context for the answer. Just answer the question directly.
                    - **Consistency Check:** If there is conflicting information between sources, report the contradiction or try to synthesize the information cautiously, indicating uncertainty if necessary.

                    **Crucially, if you generate a Markdown table, you MUST also provide semantic information about each column in the 'column_semantics' field of the JSON response.**
                    For each column in the generated Markdown table, provide:
                    - 'original_name': The exact column header as it appears in your Markdown table.
                    - 'description': A brief explanation of what this column represents.
                    - 'expected_format': The expected data format (e.g., "string", "integer", "float", "date (YYYY-MM-DD)", "currency (VND)").
                    - 'typical_values': An array of representative example values from that column. If the column is categorical, list all distinct values here (identical to values of 'category_name' in the 'value_mapping' array below). Otherwise, list a few common examples.
                    - **If a column is categorical (e.g., "Product Type", "Category"), include a 'value_mapping' array. Each object in 'value_mapping' should have 'category_name' (string), 'keywords' (array of strings), and optionally 'exclude_keywords' (array of strings) and 'description' (string). The 'keywords' should be terms that identify items belonging to that category within the column's text values. 'exclude_keywords' can be used for more precise matching (e.g., 'robusta' but not 'arabica'). Ensure these keywords are comprehensive enough to cover common variations for the category.**

                    CONTEXT:
                    """
                    ${context}
                    """

                    Current SST schema (if any): ${desiredSchemaHeaders}

                    User's original question: "${userInput}"

                    Return a valid JSON object with the following keys:
                    - "answer": String containing the full answer in Markdown.
                    - "column_semantics": An array of objects describing the semantic meaning of each column in any generated Markdown table. If no table is generated, this array should be empty.
                `;

                const finalResponseObj = await callGemini(synthesisPrompt, geminiApiKey, true, synthesisResponseSchema); 
                const finalResponse = finalResponseObj.answer;
                const columnSemantics = finalResponseObj.column_semantics || [];
                
                // Render Markdown to HTML
                const formattedResponse = marked.parse(finalResponse); 
                // Update message element with formatted response
                synthesisMessage.innerHTML = `<div class="prose max-w-none">${formattedResponse}</div>`; 

                // After rendering, find all tables and add download buttons
                let tables = synthesisMessage.querySelectorAll('table'); 
                tables.forEach((table, index) => { 
                    let columnHeaders = []; 
                    table.querySelectorAll('thead th').forEach(th => columnHeaders.push(th.innerText.trim())); 

                    let rows = []; 
                    table.querySelectorAll('tbody tr').forEach(tr => {
                        let rowData = []; 
                        tr.querySelectorAll('td').forEach(td => rowData.push(td.innerText.trim())); 
                        rows.push(rowData); 
                    });

                    if (columnHeaders.length > 0 && rows.length > 0) {
                        let csvControlContainer = document.createElement('div'); 
                        csvControlContainer.className = 'flex gap-2 mt-2 mb-4';
                        csvControlContainer.innerHTML = `
                            <button id="download-table-button-${uniqueCounter}-${index}" class="bg-blue-600 text-white p-2 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition text-sm flex items-center gap-1">
                               <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>
                                <span>Download Table (CSV)</span>
                            </button>

                            <button id="send-receiver-size-button-${uniqueCounter}-${index}" class="bg-blue-600 text-white p-3 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition flex items-center justify-center w-12 h-12 group send-receiver-size-btn">
                                <!-- Original three-bar SVG -->
                                <svg class="h-6 w-6" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect x="4" y="12" width="4" height="8" rx="1" fill="currentColor" class="bar-1"></rect>
                                    <rect x="10" y="8" width="4" height="12" rx="1" fill="currentColor" class="bar-2"></rect>
                                    <rect x="16" y="14" width="4" height="6" rx="1" fill="currentColor" class="bar-3"></rect>
                                </svg>
                            </button>
                        `;

                        // Insert button after the table
                        table.parentNode.insertBefore(csvControlContainer, table.nextSibling); 

                        const downloadButton = document.getElementById(`download-table-button-${uniqueCounter}-${index}`); 

                        downloadButton.addEventListener('click', () => { 
                            
                            let filename = `summary_table_${uniqueCounter}_${index}.csv`; 
                            // Try to get a title from a preceding heading if available
                            let previousSibling = table.previousElementSibling; 
                            while (previousSibling) { 
                                if (previousSibling.tagName.match(/^H[1-6]$/)) {
                                    // Sanitize filename: remove special chars and replace spaces with underscores
                                    filename = `${previousSibling.innerText.trim().replace(/[^a-zA-Z0-9\sÀÁẠẢÃĂẰẮẶẲẴÂẦẤẬẨẪĐÈÉẸẺẼÊỀẾỆỂỄÌÍỊỈĨÒÓỌỎÕÔỒỐỘỔỖƠỜỚỢỞỠÙÚỤỦŨƯỪỨỰỬỮỲÝẴỶỸàáạảãăằắặẳẵâầấậẩẫđèéẹẻẽêềếệểễìíịỉĩòóọỏõôồốộổỗơờớợởỡùúụủũưừỨỰỬỮỲÝÝẎỶỸ]/g, '').replace(/\s+/g, '_').toLowerCase()}.csv`;
                                    break;
                                }
                                previousSibling = previousSibling.previousElementSibling; 
                            }
                            exportSimpleTableToCsv(columnHeaders, rows, filename); 
                            
                        });
                        
                        const sendReceiverSizeButton = document.getElementById(`send-receiver-size-button-${uniqueCounter}-${index}`); 

                        // --- Event listener to control receiver iframe ---
                        sendReceiverSizeButton.addEventListener('click', () => { 
                            // Send data to receiver iframe
                            if (receiverIframe.contentWindow) {
                                receiverIframe.contentWindow.postMessage({
                                    type: 'SST_DATA_FROM_INDEX',
                                    payload: {            // <--- Thêm key "payload"
                                        columnHeaders: columnHeaders,     // <--- Đưa "sstData" vào bên trong key "data"
                                        rows: rows,
                                        columnSemantics: columnSemantics // Pass the column semantics
                                    }
                                }, 'http://localhost:5400'); // Consider restricting target origin in production
                            }
                                
                            if (currentIframeState === 'partial') { 
                                setIframeState('fullscreen'); 
                            } else if (currentIframeState === 'bookmark') { // If in bookmark state, clicking send goes to partial
                                setIframeState('partial'); 
                                setIframeState('fullscreen'); 
                            }
                        });
                        uniqueCounter = uniqueCounter+1;
                    }
                });

                // Create a container for the buttons to manage spacing
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'flex gap-2 mt-4'; // Added gap-2 for spacing and mt-4 for top margin

                // Add a button to trigger saveColumnSemantics (example placement)
                const saveColumnSemanticsButton = document.createElement('button');
                saveColumnSemanticsButton.id = `save-semantics-button${uniqueCounter}`;
                saveColumnSemanticsButton.className = 'bg-gray-500 text-white p-2 rounded-lg hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 transition text-sm flex items-center gap-1';
                saveColumnSemanticsButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-save">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                        <polyline points="17 21 17 13 7 13 7 21"/>
                        <polyline points="7 3 7 8 15 8"/>
                    </svg>
                    <span>Download Column Semantics (JSON)</span>
                `;

                buttonContainer.appendChild(saveColumnSemanticsButton);

                saveColumnSemanticsButton.addEventListener('click', () => {
                    let columnSemanticsCopy = JSON.parse(JSON.stringify(columnSemantics));
                    if (columnSemanticsCopy.length > 0) {
                        saveColumnSemantics(columnSemanticsCopy, `deep_search_column_semantics_${uniqueCounter}.json`);
                    } else {
                        displayMessage('No column semantics to download.', 'system_error');
                    }
                });

                // Add citation download button
                const downloadCsvButton = document.createElement('button');
                downloadCsvButton.className = "bg-green-600 text-white p-2 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition text-sm flex items-center gap-1";
                downloadCsvButton.id = `download-csv-button${uniqueCounter}`;
                downloadCsvButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>
                    <span>Download Citations (CSV)</span>
                `;

                buttonContainer.appendChild(downloadCsvButton);

                // Append the button container to synthesisMessage
                synthesisMessage.appendChild(buttonContainer);

                downloadCsvButton.addEventListener('click', () => { 
                    let citationDataCopy = JSON.parse(JSON.stringify(citationData)); 
                    if (citationDataCopy.length > 0) {
                        exportToCsv(citationDataCopy, `deep_search_citations_${uniqueCounter}.csv`); 
                    } else {
                        displayMessage('No citation data to download.', 'system_error'); 
                    }
                });
                
            } catch (error) {
                console.error("An error occurred:", error);
                let errorMessage = `<p class="font-semibold text-red-600">An error occurred</p><p>${error.message}. Please check your API keys and console for more details.</p>`; 
                
               // Specific message for unregistered Gemini API callers
                if (error.message.includes("401 Unauthorized")) { 
                    errorMessage = `<p class="font-semibold text-red-600">Gemini API Key Error (401 Unauthorized)</p><p>This error indicates your Gemini API key is invalid or missing. Please double-check your API key at <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-indigo-600 hover:underline">Google AI Studio</a> and enter it in the "Gemini Flash API Key" field above.</p>`;
                    apiKeySection.classList.remove('hidden'); 
                    geminiApiKeyInput.focus(); 
                } else if (!googleApiKey || !googleCx) {
                    errorMessage += `<p class="mt-2">Do you want to switch to "Quota" or "Quota (Back-end)" mode to continue without a Google Search API key? Please select one of these modes from the dropdown list.</p>`;
                }
                // Check for Backend scraping 405 error
                else if (error.message.includes("405 Method Not Allowed")) {
                    errorMessage = `<p class="font-semibold text-red-600">Backend Scraping Error (405 Method Not Allowed)</p><p>Your backend server (on Render.com) rejected the scraping request. This often happens when the HTTP method (POST) is not allowed for this URL, or the server configuration is incorrect.</p><p class="mt-2">Please check your backend deployment configuration on Render.com, ensuring the \`/api/crawl_url\` endpoint accepts POST requests.</p>`;
                }


                displayMessage(errorMessage, 'system_error'); 
            } finally {
                setLoadingState(false); 
                // Explicitly stop the bot icon spin associated with the last system message
                const lastSystemMessageContainer = chatContainer.lastElementChild; 
                if (lastSystemMessageContainer && lastSystemMessageContainer.querySelector('.lucude-bot')) {
                    lastSystemMessageContainer.classList.remove('animate-spin');
                }
            }
        });

        function setLoadingState(isLoading) { 
            chatInput.disabled = isLoading; 
            sendButton.disabled = isLoading; 
            searchModeSelector.disabled = isLoading; 
            if (isLoading) {
                sendButton.innerHTML = `<div class="w-6 h-6 border-2 border-white border-t-transparent rounded-full animate-spin"></div>`; 
            } else {
                sendButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send"><path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/></svg>`; 
            }
        }

        function displayMessage(content, sender, isLive = false) { 
            const messageElement = document.createElement('div'); 
            messageElement.className = 'flex items-start gap-3 mb-4';

            // Create a div for the icon and set its innerHTML
            const iconDiv = document.createElement('div'); 
            let contentBackground = 'bg-slate-100'; 
            let contentTextColor = 'text-slate-800'; 

            switch (sender) {
                case 'user':
                    iconDiv.className = "bg-slate-600 p-2 rounded-full flex-shrink-0";
                    iconDiv.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-user"><path d="M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>`;
                    contentBackground = 'bg-indigo-600';
                    contentTextColor = 'text-white';
                    messageElement.classList.add('justify-end');
                    break;
                case 'system_error':
                    iconDiv.className = "bg-red-500 p-2 rounded-full flex-shrink-0";
                    iconDiv.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-alert-triangle"><path d="m21.73 18-8-14a2 2 0 0 0-3.46 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><path d="M12 9v4"/><path d="M12 17h.01"/></svg></div>`;
                    contentBackground = 'bg-red-100';
                    contentTextColor = 'text-red-800';
                    break;
                case 'system_warning': // Added for warnings
                    iconDiv.className = "bg-orange-500 p-2 rounded-full flex-shrink-0";
                    iconDiv.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-alert-circle"><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></svg>`;
                    contentBackground = 'bg-orange-100';
                    contentTextColor = 'text-orange-800';
                    break;
                default: // system message
                    iconDiv.className = "bg-indigo-600 p-2 rounded-full flex-shrink-0";
                    iconDiv.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucude-bot"><path d="M12 8V4H8"/><rect width="16" height="12" x="4" y="8" rx="2"/><path d="M2 14h2"/><path d="M20 14h2"/><path d="M15 13v2"/><path d="M9 13v2"/></svg>`;
                    // Start spin for dynamic messages (thinking/searching/synthesizing)
                    if (isLive) {
                        const botSvg = iconDiv.querySelector('.lucude-bot'); 
                        if (botSvg) {
                            botSvg.classList.add('animate-spin');
                        }
                    }
                    break;
            }

            const contentDiv = document.createElement('div'); 
            contentDiv.className = `rounded-lg p-3 max-w-full ${contentBackground} ${contentTextColor}`;
            contentDiv.innerHTML = sender === 'user' ? `<p>${content}</p>` : content;

            if (sender === 'user') {
                messageElement.appendChild(contentDiv);
                messageElement.appendChild(iconDiv); // Append iconDiv
            } else {
                messageElement.appendChild(iconDiv); // Append iconDiv
                messageElement.appendChild(contentDiv);
            }

            chatContainer.appendChild(messageElement); 
            chatContainer.scrollTop = chatContainer.scrollHeight; 
            
            // Re-render icons if they were added
            lucide.createIcons();

            return isLive ? contentDiv : messageElement; 
        }

        function updateMessage(messageElement, newContent) { 
            // messageElement here is the contentDiv
            let tempDiv = document.createElement('div'); 
            tempDiv.innerHTML = newContent; // newContent is already HTML from marked.parse

            // Check if new content contains the dot-effect animation
            const hasDotEffect = tempDiv.querySelector('.dot-effect'); 

            // Find the parent messageElement, then the bot SVG
            const parentMessageElement = messageElement.closest('.flex.items-start.gap-3'); 
            const botSvg = parentMessageElement ? parentMessageElement.querySelector('.lucude-bot') : null; 

            if (botSvg) {
                if (hasDotEffect) {
                    botSvg.classList.add('animate-spin');
                } else {
                    botSvg.classList.remove('animate-spin');
                }
            }

            // Update the message element with the modified HTML
            messageElement.innerHTML = tempDiv.innerHTML;
            lucide.createIcons(); // Re-render icons after DOM manipulation
            chatContainer.scrollTop = chatContainer.scrollHeight; 
        }
        
        // Modified callGemini to accept an optional responseSchema
        async function callGemini(prompt, userProvidedApiKey, expectJson = false, responseSchema = null) { 
            const model = 'gemini-2.0-flash'; 
            let url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`; 

            const headers = { 'Content-Type': 'application/json' }; 
            
            // Log the API key being used for debugging
            console.log('callGemini: Using API Key:', userProvidedApiKey ? '***' + userProvidedApiKey.substring(userProvidedApiKey.length - 4) : 'Canvas-provided (empty string)');

            // Conditionally add API key to URL or headers
            if (userProvidedApiKey) {
                headers['x-goog-api-key'] = userProvidedApiKey; // Standard header for API key when user provides
            } else {
                // If no API key is provided by the user, append key= to the URL.
                // Canvas runtime will automatically populate the environment's API key.
                url += '?key=';
            }

            const generationConfig = expectJson ? { responseMimeType: "application/json" } : {};
            if (responseSchema) {
                generationConfig.responseSchema = responseSchema;
            }

            const requestBody = { 
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: generationConfig
            };

            console.log('callGemini: Sending request to:', url);
            console.log('callGemini: Headers:', headers);
            console.log('callGemini: Body:', JSON.stringify(requestBody, null, 2));

            try {
                const response = await fetch(url, { 
                    method: 'POST',
                    headers: headers, 
                    body: JSON.stringify(requestBody) 
                });

                console.log('callGemini: Response received - Status:', response.status, response.statusText);

                if (!response.ok) {
                    const rawErrorText = await response.text();
                    console.error('callGemini: Raw error response:', rawErrorText);

                    let errorMessage = `Gemini API Error: ${response.status} ${response.statusText}.`;

                    if (response.status === 401) {
                        errorMessage = `Gemini API Error: 401 Unauthorized. Please check your Gemini API key in the input field. It might be incorrect or not properly authorized.`;
                    } else if (rawErrorText.trim() === '') {
                        errorMessage += ` The server did not provide a detailed error message. This often indicates a fundamental issue, such as a network problem.`;
                    } else {
                        try {
                            const errorData = JSON.parse(rawErrorText);
                            errorMessage = `Gemini API Error: ${errorData.error?.message || 'An unknown error occurred with the API call.'}`;
                        } catch (parseError) {
                            errorMessage += ` Could not parse error response to JSON. Raw response: ${rawErrorText.substring(0, Math.min(rawErrorText.length, 500))}`;
                        }
                    }
                    throw new Error(errorMessage);
                }

                const data = await response.json(); 
                
                // ** START FIX FOR UNDEFINED PROPERTIES **
                if (!data.candidates || data.candidates.length === 0 || 
                    !data.candidates[0].content || !data.candidates[0].content.parts || 
                    data.candidates[0].content.parts.length === 0) {
                    console.error('callGemini: Unexpected Gemini response structure:', data);
                    throw new Error('Gemini API returned an invalid response structure.');
                }
                // ** END FIX FOR UNDEFINED PROPERTIES **

                const text = data.candidates[0].content.parts[0].text; 
                console.log('callGemini: Raw text from Gemini response:', text); // Log raw text for debugging

                if (expectJson) {
                    try {
                        return JSON.parse(text.trim()); // Trim whitespace before parsing
                    } catch (jsonParseError) { 
                        console.error("JSON parsing error from Gemini (expected JSON but received invalid):", jsonParseError, "Received text:", text);
                        throw new Error(`Gemini API returned invalid JSON. Please try again. Details: ${text.substring(0, Math.min(text.length, 500))}...`); // Show more of the raw text
                    }
                } else {
                    return text;
                }
            } catch (error) { 
                console.error("Error in callGemini:", error);
                throw error; // Re-throw to be caught by outer try-catch in chatForm.addEventListener
            }
        }

        async function callGoogleSearch(query, apiKey, cx) { 
            const url = `https://www.googleapis.com/customsearch/v1?key=${apiKey}&cx=${cx}&q=${encodeURIComponent(query)}`; 
            
            console.log('callGoogleSearch: Sending request to:', url);

            const response = await fetch(url); 
            console.log('callGoogleSearch: Response received - Status:', response.status, response.statusText);

            if (!response.ok) {
                const errorData = await response.json(); 
                console.error('callGoogleSearch: Error response:', errorData);
                throw new Error(`Google Search API Error: ${errorData.error.message}`);
            }
            return response.json();
        }

        async function callBackendScraper(urlToScrape) { 
            // Your Flask backend address. Make sure it's running!
            // Make this configurable for generality
            const backendUrl = localStorage.getItem('backendUrl') || 'http://localhost:5000/api/crawl_url'; 

            try {
                const response = await fetch(backendUrl, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ url: urlToScrape })
                });

                console.log('callBackendScraper: Response received - Status:', response.status, response.statusText);

                if (!response.ok) {
                    // Read raw text and throw error for 405, as it's not JSON
                    const errorText = await response.text(); 
                    console.error('callBackendScraper: Raw error response:', errorText);
                    throw new Error(`Backend scraping error: ${response.status} ${response.statusText}. Raw response: ${errorText.substring(0, 200)}...`);
                }
                return response.json();
            } catch (error) { 
                console.error("Error calling backend scraper:", error);
                return { error: `Could not connect to backend or scraping error: ${error.message}` };
            }
        }

        async function extractStructuredInformation(userInput, query, sourceContent, sourceUrl, sourceId, geminiApiKey, desiredSchemaHeaders = []) { 
            const model = 'gemini-2.0-flash'; 
            let url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`; 

            // Always append the key parameter to the URL.
            // If geminiApiKey is empty, Canvas runtime will automatically populate the environment's API key.
            // If geminiApiKey is present, it will be used.
            url += `?key=${geminiApiKey}`; 
            
            const headers = { 'Content-Type': 'application/json' }; 
            
            let schemaInstructions = ''; 
            let jsonSchemaProperties = {}; 
            let propertyOrdering = ["ID", "Citation Source"]; // Always include these basic fields

            if (desiredSchemaHeaders && desiredSchemaHeaders.length > 0) {
                schemaInstructions = `
                You MUST extract information and map them to the corresponding fields with the following column headers. If a column header does not find matching information, set the value as an empty string ("").
                Desired column headers: ${JSON.stringify(desiredSchemaHeaders)}.
                Specifically, for the "HTML" field, set the value as a short text snippet (max 200 characters) from the webpage content most relevant to the original question, or an empty string if none.
                `;

                // Dynamically build JSON schema properties from desiredSchemaHeaders
                desiredSchemaHeaders.forEach(header => { 
                    jsonSchemaProperties[header] = { "type": "STRING" };
                });

                // Filter desiredSchemaHeaders to remove those already in propertyOrdering basic propertyOrdering
                const filteredDesiredHeaders = desiredSchemaHeaders.filter(h => !propertyOrdering.includes(h)); 
                propertyOrdering = [...propertyOrdering, ...filteredDesiredHeaders]; // Only add unique desired headers

            } else {
                // Modified to request 'Key data points' as a JSON string within a STRING field
                schemaInstructions = `
                Return a JSON object with the following fields:
                - "Summary": A short paragraph (max 2-3 sentences) summarizing the most important content of the page related to the question.
                - "Key data points_json": A JSON string representing key-value pairs of the most important information/events/data found on the page, relevant to the original question. Example: "{\\"Highest Price\\": \\"X\\", \\"Lowest Price\\": \\"Y\\", \\"Distributor\\": \\"Z\\"}". If no key data is found, leave this JSON string empty (e.g., "{}").
                Ensure all values are strings.
                `;
                jsonSchemaProperties = {
                    "Summary": { "type": "STRING" },
                    "Key data points_json": { "type": "STRING" } // Changed to STRING
                };
                propertyOrdering = [...propertyOrdering, "Summary", "Key data points_json"]; // Add default headers to order
            }

            const extractionPrompt = `
                You are a professional AI research assistant, capable of self-assessment and optimizing the extraction process.
                Your task is to extract structured information from the provided webpage content, directly relevant to the user's original question and the search queries used.
                
                **Self-assessment and Optimization Principles:**
                - Ensure coherence: Focus solely on extracting data from the given source, do not generate new information.
                - Ensure loose coupling: The output must strictly adhere to the defined schema.
                - Ensure POLA: Extraction must be consistent and predictable.
                - If information for a field is not found, leave it empty ("").
                - Pay special attention to extracting numerical values, units, and specific attributes (e.g., brand, product type) if they are requested in the schema.

                Return a valid JSON object only. This object MUST include the following fields:
                - "ID": A unique identifier for this source (e.g., "S1", "S2").
                - "Citation Source": The full URL of the source webpage.
                ${schemaInstructions}

                User's original question: "${userInput}"
                Search query that led to this page: "${query}"
                Webpage content:
                """
                ${sourceContent}
                """
                Source URL: "${sourceUrl}"
                Source ID: "${sourceId}"
            `;
            
            const payload = { 
                contents: [{ parts: [{ text: extractionPrompt }] }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "ID": { "type": "STRING" },
                            "Citation Source": { "type": "STRING" },
                            ...jsonSchemaProperties 
                        },
                        "propertyOrdering": propertyOrdering 
                    }
                }
            };

            console.log('extractStructuredInformation: Sending request to:', url);
            console.log('extractStructuredInformation: Headers:', headers);
            console.log('extractStructuredInformation: Body:', JSON.stringify(payload, null, 2));

            try {
                const response = await fetch(url, { 
                    method: 'POST',
                    headers: headers, 
                    body: JSON.stringify(payload) 
                });

                console.log('extractStructuredInformation: Response received - Status:', response.status, response.statusText);

                if (!response.ok) {
                    let errorData; 
                    const rawErrorText = await response.text(); // Capture raw error text first
                    console.error('extractStructuredInformation: Raw error response:', rawErrorText);
                    try {
                        errorData = JSON.parse(rawErrorText); 
                    } catch (parseError) { 
                        throw new Error(`Gemini API Error during extraction: ${response.status} ${response.statusText}. Could not parse error response to JSON. Raw response: ${rawErrorText.substring(0, Math.min(rawErrorText.length, 500))}`);
                    }
                    throw new Error(`Gemini API Error during extraction: ${errorData.error.message}`);
                }

                const data = await response.json(); 
                
                // ** START FIX FOR UNDEFINED PROPERTIES **
                if (!data.candidates || data.candidates.length === 0 || 
                    !data.candidates[0].content || !data.candidates[0].content.parts || 
                    data.candidates[0].content.parts.length === 0) {
                    console.error('extractStructuredInformation: Unexpected Gemini response structure:', data);
                    throw new Error('Gemini API returned an invalid response structure during extraction.');
                }
                // ** END FIX FOR UNDEFINED PROPERTIES **

                const text = data.candidates[0].content.parts[0].text; 
                console.log('extractStructuredInformation: Raw text from Gemini response:', text); // Log raw text for debugging

                let result; 
                try {
                    result = JSON.parse(text.trim());
                } catch (jsonParseError) { 
                    console.error("JSON parsing error from Gemini in extractStructuredInformation (expected JSON but received invalid):", jsonParseError, "Received text:", text);
                    // Return default structure if parsing fails to prevent app crash
                    return {
                        ID: sourceId,
                        "Citation Source": sourceUrl,
                        "Summary": `Extraction error from this source. Original content might be invalid or API returned an error.`,
                        "Key data points": {} // Ensure it's an object for consistency
                    };
                }

                // If it's the general schema, parse the _json field into an object
                if (!desiredSchemaHeaders || desiredSchemaHeaders.length === 0) { 
                    try {
                        result['Key data points'] = JSON.parse(result['Key data points_json'] || '{}');
                        delete result['Key data points_json']; // Remove the temporary field
                    } catch (e) {
                        console.warn("Could not parse 'Key data points_json':", e, "Raw string:", result['Key data points_json']);
                        result['Key data points'] = {}; // Default to empty object in case of parsing error
                    }
                }
                return result;

            } catch (error) { 
                console.error("Error extracting structured information:", error);
                // Return default structure if parsing fails to prevent app crash
                return {
                    ID: sourceId,
                    "Citation Source": sourceUrl,
                    "Summary": `Extraction error from this source. Original content might be invalid or API returned an error: ${error.message}`,
                    "Key data points": {} // Ensure it's an object for consistency
                };
            }
        }

        function escapeCsv(value) { 
            if (value === null || value === undefined) {
                return '';
            }
            let stringValue = String(value); 
            if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                return `"${stringValue.replace(/"/g, '""')}"`;
            }
            return stringValue;
        }

        function exportToCsv(data, filename) { 
            if (data.length === 0) return;

            // Collect all unique headers, including nested keys from "Key data points"
            const allHeaders = new Set(); 
            data.forEach(row => { 
                Object.keys(row).forEach(key => { 
                    if (key === 'Key data points' && typeof row[key] === 'object' && row[key] !== null) {
                        Object.keys(row[key]).forEach(nestedKey => allHeaders.add(nestedKey)); 
                    } else if (key !== 'Key data points_json') { // Exclude the temporary JSON string field
                        allHeaders.add(key);
                    }
                });
            });

            // Ensure mandatory headers are at the beginning
            const mandatoryHeaders = ["ID", "Citation Source", "Summary"]; 
            let finalHeaders = mandatoryHeaders.filter(h => allHeaders.has(h)); 
            // Add other headers, excluding "Key data points" and the temporary JSON string field
            Array.from(allHeaders).sort().forEach(h => { 
                if (!mandatoryHeaders.includes(h) && h !== 'Key data points' && h !== 'Key data points_json') {
                    finalHeaders.push(h);
                }
            });
            // Add nested keys from "Key data points" at the end
            const nestedHeaders = new Set(); 
            data.forEach(row => { 
                if (row['Key data points'] && typeof row['Key data points'] === 'object') {
                    Object.keys(row['Key data points']).forEach(key => nestedHeaders.add(key)); 
                }
            });
            Array.from(nestedHeaders).sort().forEach(h => finalHeaders.push(h)); 


            let csvContent = finalHeaders.map(escapeCsv).join(',') + '\n'; 

            data.forEach(row => { 
                const rowValues = finalHeaders.map(header => { 
                    if (row.hasOwnProperty(header)) {
                        return escapeCsv(row[header]);
                    } else if (row['Key data points'] && typeof row['Key data points'] === 'object' && row['Key data points'].hasOwnProperty(header)) {
                        return escapeCsv(row['Key data points'][header]);
                    }
                    return ''; // Empty string for missing values
                });
                csvContent += rowValues.join(',') + '\n'; 
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a'); 
            if (link.download !== undefined) { // feature detection
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                displayMessage('Your browser does not support direct CSV download.', 'system_error'); 
            }
        }
        
        

        // Function to save columnSemantics to a JSON file
        function saveColumnSemantics(columnSemantics, filename) {
            if (columnSemantics.length === 0) {
                alert('Không có dữ liệu ngữ nghĩa cột để lưu.');
                return;
            }
            const jsonString = JSON.stringify(columnSemantics, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function exportSimpleTableToCsv(columnHeaders, rows, filename) { 
            let csvContent = columnHeaders.map(escapeCsv).join(',') + '\n'; 
            rows.forEach(row => { 
                csvContent += row.map(escapeCsv).join(',') + '\n'; 
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a'); 
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                displayMessage('Your browser does not support direct CSV download.', 'system_error');
            }
        }

        // Close button in fullscreen header
        receiverFullscreenHeader.querySelector('#close-receiver-button').addEventListener('click', () => { 
            setIframeState('partial'); 
        });

        receiverFullscreenHeader.querySelector('#refresh-receiver-button').addEventListener('click', () => { 
            const currentSrc = receiverIframe.src; 
            receiverIframe.src = currentSrc; // Reassign src to reload iframe
            console.log('Iframe reloaded!');
        });

        // Click listener for bookmark tab (to toggle partial/bookmark)
        iframeBookmarkTab.addEventListener('click', (e) => { 
            // Only send if not dragging
            if (!isDragging) { 
                if (currentIframeState === 'bookmark') { 
                    setIframeState('partial'); 
                } else if (currentIframeState === 'partial') { 
                    setIframeState('bookmark'); 
                }
            }
        });

        // Drag functionality for bookmark tab
        iframeBookmarkTab.addEventListener('mousedown', startDrag); 
        iframeBookmarkTab.addEventListener('touchstart', startDrag, { passive: false });

        function startDrag(e) { 
            if (currentIframeState !== 'partial') return; // Only allow dragging from partial state

            isDragging = true; 
            startX = e.clientX || e.touches[0].clientX; 
            initialIframeWidth = receiverContainer.offsetWidth; 

            // Disable transitions while dragging for immediate response
            setIframeState(currentIframeState, true); // Call with disableTransition = true

            document.addEventListener('mousemove', drag); 
            document.addEventListener('mouseup', endDrag); 
            document.addEventListener('touchmove', drag, { passive: false }); 
            document.addEventListener('touchend', endDrag); 
        }

        function drag(e) { 
            if (!isDragging) return; 
            if ((!e.clientX) && (!e.touches)) return; 

            const currentX = e.clientX || e.touches[0].clientX; 
            const deltaX = currentX - startX; 

            let newWidth = initialIframeWidth - deltaX; 

            // Constrain newWidth to avoid going off screen or negative
            newWidth = Math.max(0, Math.min(window.innerWidth, newWidth)); 

            receiverContainer.style.width = `${newWidth}px`; 
            // Bookmark tab's right position is equal to the iframe's current width
            iframeBookmarkTab.style.right = `${newWidth}px`; 

            e.preventDefault(); // Prevent scrolling on touch devices
        }

        function endDrag(e) { 
            if (!isDragging) return; 
            isDragging = false; 

            document.removeEventListener('mousemove', drag); 
            document.removeEventListener('mouseup', endDrag); 
            document.removeEventListener('touchmove', drag); 
            document.removeEventListener('touchend', endDrag); 

            const finalWidth = receiverContainer.offsetWidth; 
            const windowWidth = window.innerWidth; 

            // Determine next state based on final width
            if (finalWidth > windowWidth * (FULLSCREEN_THRESHOLD_VW / 100)) { 
                setIframeState('fullscreen'); 
            } else if (finalWidth < windowWidth * (BOOKMARK_THRESHOLD_VW / 100)) { 
                setIframeState('bookmark'); 
            } else {
                setIframeState('partial'); 
            }
        }

        // Add keydown listener to document for Esc key to exit fullscreen
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (currentIframeState === 'fullscreen') {
                    setIframeState('partial');
                }
            }
        });

        // Initial setup
        setIframeState('bookmark'); 
        lucide.createIcons(); // Still useful for other Lucide icons in the app

    </script>
</body>
</html>
